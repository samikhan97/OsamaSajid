#include <iostream>
#include <conio.h>
#include <string>

using namespace std;

class LinkedString {
	
private:
	struct node {
		char ch;
		node* next;

		node(char x) {
			ch = x;
			next = nullptr;
		}

		node(const node* n) {
			ch = n->ch; 
			next = n->next;
		}
	};
	int length;
	node* head, *tail;
	void deallocate(node*);
	bool findString(const string&, node*&, node*&);

public:
	LinkedString();
	LinkedString(const LinkedString&);
	LinkedString(const string&);
	const LinkedString operator=(const LinkedString&);
	friend ostream& operator<<(ostream&, const LinkedString&);
	friend istream& operator<<(istream&, const LinkedString&);
	int getLength();
	~LinkedString();
	LinkedString operator+(const LinkedString&);
	bool find(const string&);
	bool find(const LinkedString&);
	LinkedString findAndCopy(const string&);
	LinkedString findAndCut(const string&);
	void findAndReplace(const string&, const string&);
	void findAndInsertAfter(const string&, const string&);
	void findAndInvert(const string&);
	void reverse();
};

bool LinkedString::findString(const string& str, node*& uHead, node*& uTail) {
	if(length >= str.length()) {
		int index = 0;
		char matchChar = str[index];
		node* currentChar = head;
		node* prevChar = nullptr;
		for(int x = 0; x < length; x++) {
			if(currentChar->ch == matchChar) {
				if(index == str.length() - 1) {
					uTail = currentChar;
					return true;
				}
				if(index == 0) {
					uHead = prevChar;
				}
				matchChar = str[++index];
			} else {
				matchChar = str[0];
				index = 0;
				if(length - x < str.length()) {
					return false;
				}
			}
			prevChar = currentChar;
			currentChar = currentChar->next;
		}
	}
	return false;
}

void LinkedString::deallocate(node* head) {
	if(head != nullptr && length > 0) {
		deallocate(head->next);
		delete head;
	}
}

LinkedString::LinkedString() {
	length = 0;
	head = tail = nullptr;
}

LinkedString::LinkedString(const string& str) {
	node* current = nullptr;
	if(str.length() > 0) {
		current = new node(str[0]);
		head= current;
		for(int x = 1; x < str.length(); x++) {
			current->next = new node(str[x]);
			current = current->next;
		}
		tail = current;
		current->next = nullptr;
	}
	length = str.length();
}

LinkedString::LinkedString(const LinkedString& str) {
	node* current = nullptr;
	node* strCurrent = nullptr;
	if(str.length > 0) {
		strCurrent = str.head;
		current = new node(strCurrent->ch);
		head = current;
		while (strCurrent->next != nullptr) {
			strCurrent = strCurrent->next;
			current->next = new node(strCurrent->ch);
			current = current->next;
		}
		tail = current;
		current->next = nullptr;
	}
	length = str.length;
}

int LinkedString::getLength() {
	return length;
}

LinkedString::~LinkedString() {
	deallocate(head);
}

const LinkedString LinkedString::operator=(const LinkedString& str) {
	if(&str != this) {
		deallocate(head);
		node* current = nullptr;
		node* strCurrent = nullptr;
		if(str.length > 0) {
			strCurrent = str.head;
			current = new node(strCurrent->ch);
			head = current;
			while (strCurrent->next != nullptr) {
				strCurrent = strCurrent->next;
				current->next = new node(strCurrent->ch);
				current = current->next;
			}
			tail = current;
			current->next = nullptr;
		}
		length = str.length;
	}
	return *this;
}

LinkedString LinkedString::operator+(const LinkedString& str) {
	LinkedString newString = *this;
	if(str.length > 0) {
		node* current = str.head;
		do {
			node* newNode = new node(current);
			newString.tail->next = newNode;
			newString.tail = newString.tail->next;
			current = current->next;
		} while (current != nullptr);
	}
	newString.length = length + str.length;
	return newString;
}

bool LinkedString::find(const string& str) {
	node* headPtr = nullptr, *tailPtr = nullptr;
	return findString(str, headPtr, tailPtr);
}

bool LinkedString::find(const LinkedString& str) {
	if(length >= str.length) {
		node* currentChar = head;
		node* matchChar = str.head;
		for(int x = 0; x < length; x++) {
			if(currentChar->ch == matchChar->ch) {
				matchChar = matchChar->next;
				if(matchChar->next == nullptr) {
					return true;
				}
			} else {
				matchChar = str.head;
				if(length - x < str.length) {
					return false;
				}
			}
			currentChar = currentChar->next;
		}
	}
	return false;
}

LinkedString LinkedString::findAndCopy(const string& str) {
	node* headPtr = nullptr, *tailPtr = nullptr;
	LinkedString copiedStr;
	node* current;
	if(findString(str, headPtr, tailPtr)) {
		if(headPtr != nullptr) {
			current = headPtr->next;
		} else {
			current = head;
		}
		node* nextTailPtr = tailPtr->next;
		copiedStr.head = new node(current);
		copiedStr.tail = copiedStr.head;
		while (current != tailPtr) {
			current = current->next;
			copiedStr.tail->next = new node(current->ch);
			copiedStr.tail = copiedStr.tail->next;
		}
		copiedStr.tail->next = nullptr;
		copiedStr.length = str.length();
	}
	return copiedStr;
}

LinkedString LinkedString::findAndCut(const string& str) {
	node* headPtr = nullptr, *tailPtr = nullptr;
	LinkedString copiedStr;
	node* current;
	if(findString(str, headPtr, tailPtr)) {
		//Copying
		if(headPtr != nullptr) {
			current = headPtr->next;
		} else {
			current = head;
		}
		node* nextTailPtr = tailPtr->next;
		copiedStr.head = new node(current);
		copiedStr.tail = copiedStr.head;
		while (current != tailPtr) {
			current = current->next;
			copiedStr.tail->next = new node(current->ch);
			copiedStr.tail = copiedStr.tail->next;
		}
		copiedStr.tail->next = nullptr;
		copiedStr.length = str.length();
		//Removing
		if(headPtr == nullptr) {
			current = head;
		} else {
			current = headPtr->next;
		}
		while(current != nextTailPtr){
			node* temp = current;
			current = current->next;
			delete temp;
		}
		if(headPtr != nullptr) {
			headPtr->next = nextTailPtr;
		} else {
			head = nextTailPtr;
		}
		length = length - str.length();
	}
	return copiedStr;
}

void LinkedString::findAndReplace(const string& findStr, const string& replaceStr) {
	node* headPtr = nullptr, *tailPtr = nullptr;
	node* current;
	if(findString(findStr, headPtr, tailPtr)) {
		if(headPtr == nullptr) {
			current = head;
		} else {
			current = headPtr->next;
		}
		node* nextTailPtr = tailPtr->next;
		//Removing
		for(int x = 0; x < findStr.length(); x++) {
			node* temp = current;
			current = current->next;
			delete temp;
		}
		if(headPtr != nullptr) {
			headPtr->next = current;
		} else {
			head = current;
		}
		
		//Inserting
		LinkedString* insertString = new LinkedString(replaceStr);
		if(headPtr != nullptr) {
			headPtr->next = insertString->head;
		} else {
			head = insertString->head;
		}
		insertString->tail->next = nextTailPtr;
		length = length - findStr.length() + replaceStr.length();
	}
}

void LinkedString::findAndInsertAfter(const string& findStr, const string& userStr){
	node* headPtr = nullptr, *tailPtr = nullptr;
	if(findString(findStr, headPtr, tailPtr)) {
		LinkedString* insertString = new LinkedString(userStr);
		if(tailPtr->next == nullptr) {
			tailPtr->next = insertString->head;
		} else {
			insertString->tail->next = tailPtr->next;
			tailPtr->next = insertString->head;
		}
	}
}

void LinkedString::findAndInvert(const string& str) {
	node* headPtr = nullptr, *tailPtr = nullptr;
	if(findString(str, headPtr, tailPtr)) {
		node *current = headPtr->next, *next = current->next, *begin = tailPtr, *temp;
		do {
			temp = current;
			current = current->next;
			next = current->next;
			current->next = headPtr->next;
			temp->next = next;
			headPtr->next = current;
			current = temp;
		}while(headPtr->next != begin);
	}
}

void LinkedString::reverse() {
	node *current = head, *next = head->next, *begin = tail, *temp;
	do {
		temp = current;
		current = current->next;
		next = current->next;
		current->next = head;
		temp->next = next;
		head = current;
		current = temp;
	}while(head != begin);
	current->next = nullptr;
}

ostream& operator<<(ostream& out, const LinkedString& str) {
	if(str.length > 0) {
		LinkedString::node* current = str.head;
		while(current != nullptr) {
			out << current->ch;
			current = current->next;
		}
	} else {
		out << "";
	}
	return out;
}

istream& operator>>(istream& in, LinkedString& str) {
	string input;
	getline(in, input);
	LinkedString temp(input);
	str = temp;
	return in;
}

int main() {
	
	char choice = NULL; 
	LinkedString linkStr1, linkStr2, linkStr3;
	string str, str2;
	while (choice != 27) {
		system("CLS");
		cout << "\n\n\n\t\t\t*** LinkedStrings and Operations ***" << 
			"\n\t\t\t1. Add two LinkedStrings\n\t\t\t2. Find a String\n\t\t\t3. Find a LinkedString\n\t\t\t4. Find and copy an LS" <<
			"\n\t\t\t5. Find and Cut an LS\n\t\t\t6. Find and Replace an LS\n\t\t\t7. Find and Insert After an LS" <<
			"\n\t\t\t8. Find and Invert an LS\n\t\t\t9. Reverse a LinkedString\n\n\t\t\tPress ESC to Exit" << endl;
		choice = _getch();
		system("CLS");
		switch (choice)
		{
		case '1':
			cout << "\n\t\t\tAdd two LinkedStrings\n" << endl;
			cout << "Enter first string: ";
			cin >> linkStr1;
			cout << "Enter second string: ";
			cin >> linkStr2;
			linkStr3 = linkStr1 + linkStr2;
			cout << linkStr3 << endl;
			break;
		case '2':
			cout << "\n\t\t\tFind a String\n" << endl;
			cout << "Enter base string: ";
			cin >> linkStr1;
			cout << "Enter string to find: ";
			getline(cin, str);
			if(linkStr1.find(str)) {
				cout << "String found!" << endl;
			} else {
				cout << "String not found!" << endl;
			}
			break;
		case '3':
			cout << "\n\t\t\tFind a LinkedString\n" << endl;
			cout << "Enter base string: ";
			cin >> linkStr1;
			cout << "Enter string to copy: ";
			cin >> linkStr2;
			if(linkStr1.find(linkStr2)) {
				cout << "String found!" << endl;
			} else {
				cout << "String not found!" << endl;
			}
			break;
		case '4':
			cout << "\n\t\t\tFind and copy an LinkedString\n" << endl;
			cout << "Enter base string: ";
			cin >> linkStr1;
			cout << "Enter string to copy: ";
			getline(cin, str);
			linkStr3 = linkStr1.findAndCopy(str);
			if(linkStr3.getLength() > 0) {
				cout << "Copied String: " << linkStr3 << endl;
				cout << "Base String After Copying: " << linkStr1 << endl;
			} else {
				cout << "String not found." << endl;
			}
			break;
		case '5':
			cout << "\n\t\t\tFind and Cut an LinkedString\n" << endl;
			cout << "Enter base string: ";
			cin >> linkStr1;
			cout << "Enter string to cut: ";
			getline(cin, str);
			linkStr3 = linkStr1.findAndCut(str);
			if(linkStr3.getLength() > 0) {
				cout << "Copied String: " << linkStr3 << endl;
				cout << "Base String After cutting: " << linkStr1 << endl; 
			} else {
				cout << "String not found." << endl;
			}
			break;
		case '6':
			cout << "\n\t\t\tFind and Replace an LinkedString\n" << endl;
			cout << "Enter base string: ";
			cin >> linkStr1;
			cout << "Enter string to find: ";
			getline(cin, str);
			cout << "Enter string to replace: ";
			getline(cin, str2);
			cout << "Base String before replacing: " << linkStr1 << endl; 
			linkStr1.findAndReplace(str, str2);
			cout << "Base String After replacing \"" << str << "\" with \"" << str2 << "\": \n" << linkStr1 << endl; 
			break;
		case '7':
			cout << "\n\t\t\tFind and Insert After an LinkedString\n" << endl;
			cout << "Enter base string: ";
			cin >> linkStr1;
			cout << "Enter string to find: ";
			getline(cin, str);
			cout << "Enter string to insert: ";
			getline(cin, str2);
			cout << "Base String before inserting: " << linkStr1 << endl; 
			linkStr1.findAndInsertAfter(str, str2);
			cout << "Base String After inserting \"" << str2 << "\" after \"" << str << "\": \n" << linkStr1 << endl; 
			break;
		case '8':
			cout << "\n\t\t\tFind and Invert a LinkedString\n" << endl;
			cout << "Enter base string: ";
			cin >> linkStr1;
			cout << "Enter string to find: ";
			getline(cin, str);
			cout << "Base String before inverting: " << linkStr1 << endl; 
			linkStr1.findAndInvert(str);
			cout << "Base String After inverting \"" << str << "\": \n" << linkStr1 << endl; 
			break;
		case '9':
			cout << "\n\t\t\tReverse a LinkedString\n" << endl;
			cout << "Enter base string: ";
			cin >> linkStr1;
			cout << "Base String before inverting: " << linkStr1 << endl; 
			linkStr1.reverse();
			cout << "Base String After reversing: \n" << linkStr1 << endl; 
			break;
		default:
			break;
		}
		if(choice != 27) {
			cout << "\n\nPress any key to return to menu." << endl;
			_getch();
		}
	}
	
	/*

	//This is the sample code as given in assignment. You can uncomment this one and comment above part to test this one as well.

	string temp1 = "hello", temp2 = "world", temp3 = " my ", temp4 = "hashir";
	LinkedString str1(temp1), str2(temp2), str3(temp3), str4(temp4);
	cout << "str1 = " << str1 << endl;
	cout << "str2 = " << str2 << endl;

	str3 = str1 + str3 + str2;
	cout << "str3 = " << str3 << endl;
	str3.findAndReplace("my", "bad");
	cout << "str3 = " << str3 << endl;
	str1 = str3.findAndCut(" world");
	cout << "str3 = " << str3 << endl;
	cout << "str1 = " << str1 << endl;
	str2 = str1.findAndCopy("ba");
	cout << "str2 = " << str2 << endl;
	str3.findAndInsertAfter("hello ", "mad ");
	cout << "str3 = " << str3 << endl;
	str4.reverse();
	cout << "str4 = " << str4 << endl;
	str3.findAndInvert("ello");
	cout << "str3 = " << str3 << endl;
	_getwch();
	*/
	return 0;
}
