// Client side C/C++ program to demonstrate Socket programming
#include <stdio.h>
#include <sys/socket.h>
#include <stdlib.h>
#include <netinet/in.h>

#include <semaphore.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <termios.h>

#include <semaphore.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>


#define PORT 8080

#define SHMSIZE     1024

char getch() 
{
    char buf = 0;
    struct termios old = { 0 };
    fflush(stdout);
    if (tcgetattr(0, &old) < 0) perror("tcsetattr()");
    old.c_lflag    &= ~ICANON;   // local modes = Non Canonical mode
    old.c_lflag    &= ~ECHO;     // local modes = Disable echo. 
    old.c_cc[VMIN]  = 1;         // control chars (MIN value) = 1
    old.c_cc[VTIME] = 0;         // control chars (TIME value) = 0 (No time)
    if (tcsetattr(0, TCSANOW, &old) < 0) perror("tcsetattr ICANON");
    if (read(0, &buf, 1) < 0) perror("read()");
    old.c_lflag    |= ICANON;    // local modes = Canonical mode
    old.c_lflag    |= ECHO;      // local modes = Enable echo. 
    if (tcsetattr(0, TCSADRAIN, &old) < 0) perror ("tcsetattr ~ICANON");
    return buf;
}
int main(int argc, char const *argv[])
{


    struct sockaddr_in address;
    int sock = 0, valread;
    struct sockaddr_in serv_addr;
   
    char buffer[1024] = {0};
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        printf("\n Socket creation error \n");
        return -1;
    }
  
    memset(&serv_addr, '0', sizeof(serv_addr));
  
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);
      
    // Convert IPv4 and IPv6 addresses from text to binary form
    if(inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr)<=0) 
    {
        printf("\nInvalid address/ Address not supported \n");
        return -1;
    }
  
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
    {
        printf("\nConnection Failed \n");
        return -1;
    }

 

   key_t key = ftok("shmfile",65);
  key_t key1 = ftok("shmfile",65);
 
      int id_sem = shmget(key,1024,0666|IPC_CREAT);
      int id_cs = shmget(key1,1024,0666|IPC_CREAT);
 
  sem_t *semaphore;
  sem_t *sem;
  if (id_sem==-1 || id_cs==-1)
  {
   printf("ERROR!");
    return 1;
    
  }
semaphore= (sem_t*) shmat(id_sem, NULL, 0);
sem= (sem_t*) shmat(id_sem, NULL, 0);

  char * str= (char*) shmat(id_cs, (void*)0, 0);




while (1){
char hello [100] ;
 int pid = fork();

if (pid==0){
str[0]='0';
 valread = read( sock , buffer, 1024);
    printf("%s\n",buffer );

}
else {
  printf("Enter the message\n");
    scanf("%s", hello);
 send(sock , hello , strlen(hello) , 0 );  

 str[0]='1';

    printf("Data written in memory: %s\n",str);
}

}




    return 0;
}
